/*
 * Copyright 2016 The University of Oklahoma.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "confloader.h"
#include "constants.h"

//This char/string separates tags from values in a line
#define DELIM '='
//This char/string denotes a line as a comment
#define COMMENT '#'
#define HEADER_START '['
#define HEADER_END ']'

namespace Soro {

bool ConfLoader::load(QTextStream& stream) {
    _contents.clear();

    QString line;
    do {
        line = stream.readLine().trimmed();
        if (line.isEmpty() ||
                line.startsWith(COMMENT) ||
                (line.startsWith(HEADER_START) && line.endsWith(HEADER_END))) {
            continue;
        }
        int sepIndex = line.indexOf(DELIM);
        if (sepIndex < 0) return false;
        QString tag = line.mid(0, sepIndex).trimmed().toLower();
        QString value = line.mid(sepIndex + 1).trimmed();
        if (value.contains(DELIM)) return false;
        _contents.insert(tag, value);
    } while (!line.isNull());
    return true;
}

bool ConfLoader::load(QFile& file) {
    if (!file.exists()) return false;
    if (!file.isOpen()) {
        if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) return false;
    }
    QTextStream stream(&file);
    bool success = load(stream);
    file.close();
    return success;
}

bool ConfLoader::write(QFile& file) const {
    if (!file.open(QIODevice::ReadWrite | QIODevice::Truncate)) return false;
    QTextStream stream(&file);
    stream << COMMENT << "This file was generated by a program, modify at your own risk" << endl;
    for (QString tag : _contents.keys()) {
        stream << tag << DELIM << _contents.value(tag) << endl;
    }
    file.close();
    return true;
}

bool ConfLoader::contains(const QString &tag) const {
    return _contents.contains(tag.toLower());
}

QString ConfLoader::value(const QString &tag) const {
    return _contents.value(tag.toLower(), "");
}

bool ConfLoader::valueAsInt(const QString &tag, int* value) const {
    bool success;
    *value = this->value(tag).toInt(&success);
    return success;
}

bool ConfLoader::valueAsIntRange(const QString &tag, int *values) const {
    bool success;
    QStringList numbers = value(tag).split("-");
    if (numbers.length() != 2) return false;
    values[0] = numbers[0].toInt(&success);
    if (!success) return false;
    values[1] = numbers[1].toInt(&success);
    return success;
}

bool ConfLoader::valueAsBool(const QString &tag, bool* value) const {
    QString rawValue = this->value(tag).toLower();
    if (rawValue == "true" || rawValue == "1") {
        *value = true;
        return true;
    }
    else if (rawValue == "false" || rawValue == "0") {
        *value = false;
        return true;
    }
    return false;
}

bool ConfLoader::valueAsIP(const QString &tag, QHostAddress* value, bool allowV6) const {
    QString rawValue = this->value(tag);
    if (QRegExp(IPV4_REGEX).exactMatch(rawValue) || (allowV6 && QRegExp(IPV6_REGEX).exactMatch(rawValue))) {
            value->setAddress(rawValue);
            return true;
    }
    return false;
}

QList<QString> ConfLoader::valueAsStringList(const QString &tag) const {
    QString rawValue = value(tag).trimmed();
    QList<QString> list;
    while (!rawValue.isEmpty()) {
        int end = rawValue.indexOf(",");
        if (end < 0) {
            list.append(rawValue);
            break;
        }
        list.append(rawValue.mid(0, end));
        rawValue = rawValue.mid(end + 1).trimmed();
    }
    return list;
}

int ConfLoader::count() const {
    return _contents.size();
}

bool ConfLoader::remove(const QString &tag) {
    return _contents.remove(tag.toLower()) > 0;
}

void ConfLoader::insert(const QString& tag, const QString& value) {
    _contents.insert(tag.toLower(), value);
}

QList<QString> ConfLoader::tags() const {
    return _contents.keys();
}

}
